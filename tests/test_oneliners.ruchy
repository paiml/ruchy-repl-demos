// Test suite for one-liner demos
import { assert, assert_equals, assert_contains, describe, it, test_report } from "./test_framework.ruchy"

// Helper to execute one-liner and capture output
fun test_oneliner(code) {
    // In real implementation, this would execute via ruchy -e
    // For now, we'll test the code patterns themselves
    ruchy_eval(code)
}

describe("Text Processing One-Liners", || {
    it("should reverse strings", || {
        let code = '"hello".chars().rev().collect::<String>()'
        // Test the pattern, not execution (since we're in test environment)
        assert_contains(code, "rev()", "Should use rev() for reversal")
        assert_contains(code, "chars()", "Should use chars() for string iteration")
    })
    
    it("should convert to uppercase", || {
        let result = "hello".to_uppercase()
        assert_equals(result, "HELLO", "Uppercase conversion")
    })
    
    it("should convert to lowercase", || {
        let result = "WORLD".to_lowercase()
        assert_equals(result, "world", "Lowercase conversion")
    })
    
    it("should trim whitespace", || {
        let result = "  hello world  ".trim()
        assert_equals(result, "hello world", "Trim whitespace")
    })
    
    it("should count words", || {
        let text = "hello world from ruchy"
        let words = text.split_whitespace().count()
        assert_equals(words, 4, "Should count 4 words")
    })
    
    it("should check for palindromes", || {
        fun is_palindrome(s) {
            let clean = s.to_lowercase().chars().filter(|c| c.is_alphanumeric()).collect()
            clean == clean.chars().rev().collect()
        }
        assert(is_palindrome("racecar"), "racecar is palindrome")
        assert(is_palindrome("A man a plan a canal Panama"), "Classic palindrome")
        assert(!is_palindrome("hello"), "hello is not palindrome")
    })
})

describe("Math Calculation One-Liners", || {
    it("should calculate factorial", || {
        fun factorial(n) { (1..=n).product() }
        assert_equals(factorial(5), 120, "5! = 120")
        assert_equals(factorial(10), 3628800, "10! = 3628800")
    })
    
    it("should generate fibonacci", || {
        fun fib(n) {
            let mut a = 0
            let mut b = 1
            for _ in 0..n {
                let tmp = a
                a = b
                b = tmp + b
            }
            a
        }
        assert_equals(fib(10), 55, "10th fibonacci = 55")
    })
    
    it("should calculate average", || {
        let nums = [1, 2, 3, 4, 5]
        let avg = nums.iter().sum() / nums.len()
        assert_equals(avg, 3, "Average of 1-5 is 3")
    })
    
    it("should check prime numbers", || {
        fun is_prime(n) {
            n > 1 && (2..n).all(|i| n % i != 0 || i * i > n)
        }
        assert(is_prime(7), "7 is prime")
        assert(is_prime(13), "13 is prime")
        assert(!is_prime(4), "4 is not prime")
    })
    
    it("should calculate GCD", || {
        fun gcd(a, b) {
            if b == 0 { a } else { gcd(b, a % b) }
        }
        assert_equals(gcd(48, 18), 6, "GCD of 48 and 18 is 6")
        assert_equals(gcd(100, 35), 5, "GCD of 100 and 35 is 5")
    })
})

describe("Data Analysis One-Liners", || {
    it("should calculate mean", || {
        let data = [1.0, 2.0, 3.0, 4.0, 5.0]
        let mean = data.iter().sum() / data.len()
        assert_equals(mean, 3.0, "Mean of 1-5 is 3")
    })
    
    it("should find median", || {
        fun median(nums) {
            let mut sorted = nums.clone()
            sorted.sort()
            let len = sorted.len()
            if len % 2 == 0 {
                (sorted[len/2 - 1] + sorted[len/2]) / 2.0
            } else {
                sorted[len/2]
            }
        }
        assert_equals(median([1, 2, 3, 4, 5]), 3, "Median of 1-5 is 3")
        assert_equals(median([1, 2, 3, 4]), 2.5, "Median of 1-4 is 2.5")
    })
    
    it("should calculate variance", || {
        let data = [1.0, 2.0, 3.0, 4.0, 5.0]
        let mean = data.iter().sum() / data.len()
        let variance = data.iter().map(|x| (x - mean) * (x - mean)).sum() / data.len()
        assert_equals(variance, 2.0, "Variance of 1-5 is 2")
    })
})

describe("Functional Chain One-Liners", || {
    it("should filter, map, and reduce", || {
        let result = [1, 2, 3, 4, 5, 6]
            .iter()
            .filter(|x| x % 2 == 0)
            .map(|x| x * 2)
            .sum()
        assert_equals(result, 24, "Sum of doubled evens: 4+8+12=24")
    })
    
    it("should compose multiple operations", || {
        let data = ["apple", "banana", "cherry", "date"]
        let result = data
            .iter()
            .filter(|s| s.len() > 4)
            .map(|s| s.to_uppercase())
            .collect()
        assert_equals(result.len(), 3, "3 fruits with >4 chars")
        assert_contains(result[0], "APPLE", "First should be APPLE")
    })
    
    it("should use fold for accumulation", || {
        let result = [1, 2, 3, 4, 5]
            .iter()
            .fold(0, |acc, x| acc + x * x)
        assert_equals(result, 55, "Sum of squares: 1+4+9+16+25=55")
    })
    
    it("should zip and transform", || {
        let nums = [1, 2, 3]
        let strs = ["a", "b", "c"]
        let zipped = nums.iter().zip(strs.iter())
        let count = zipped.count()
        assert_equals(count, 3, "Should have 3 pairs")
    })
})

describe("File Operation One-Liners", || {
    it("should handle file paths", || {
        let path = "/path/to/file.txt"
        assert_contains(path, ".txt", "Should have .txt extension")
        assert_contains(path, "/", "Should have path separators")
    })
    
    it("should process CSV-like data", || {
        let csv_line = "name,age,city"
        let fields = csv_line.split(',').collect()
        assert_equals(fields.len(), 3, "Should have 3 fields")
        assert_equals(fields[0], "name", "First field is name")
    })
})

describe("System Scripting One-Liners", || {
    it("should generate random numbers", || {
        // Test random number generation pattern
        fun random_in_range(min, max) {
            // Simplified for testing
            min + ((max - min) / 2)
        }
        let num = random_in_range(1, 10)
        assert(num >= 1 && num <= 10, "Random number in range")
    })
    
    it("should format timestamps", || {
        // Test timestamp formatting patterns
        let timestamp = "2024-01-15T10:30:00"
        assert_contains(timestamp, "2024", "Should contain year")
        assert_contains(timestamp, "T", "Should have T separator")
    })
    
    it("should encode/decode base64", || {
        // Test base64 pattern (simplified)
        let text = "hello"
        // In real implementation would use actual base64
        let encoded = text.chars().map(|c| c as u8).collect()
        assert(encoded.len() > 0, "Should produce encoded output")
    })
})

// Run the test report
test_report()