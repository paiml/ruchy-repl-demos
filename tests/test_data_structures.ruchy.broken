// Test suite for data structure REPL demos
import { assert, assert_equals, assert_contains, assert_gt, describe, it, test_report } from "./test_framework.ruchy"

describe("Arrays and Vectors", || {
    it("should create and manipulate arrays", || {
        let arr = [1, 2, 3, 4, 5]
        assert_equals(arr.len(), 5, "Array length")
        assert_equals(arr[0], 1, "First element")
        assert_equals(arr[arr.len() - 1], 5, "Last element")
    })
    
    it("should support array methods", || {
        let mut arr = [1, 2, 3]
        arr.push(4)
        assert_equals(arr.len(), 4, "After push")
        
        let popped = arr.pop()
        assert_equals(popped, 4, "Popped value")
        assert_equals(arr.len(), 3, "After pop")
    })
    
    it("should support vector operations", || {
        let vec = vec![1, 2, 3]
        assert_equals(vec.len(), 3, "Vector length")
        
        let vec2 = vec.clone()
        assert_equals(vec2.len(), 3, "Cloned vector")
    })
    
    it("should handle array slicing", || {
        let arr = [0, 1, 2, 3, 4, 5]
        let slice = arr[1..4]
        assert_equals(slice.len(), 3, "Slice length")
        assert_equals(slice[0], 1, "Slice first")
        assert_equals(slice[2], 3, "Slice last")
    })
})

describe("HashMaps", || {
    it("should create and use hashmaps", || {
        let mut map = HashMap::new()
        map.insert("key1", "value1")
        map.insert("key2", "value2")
        
        assert_equals(map.len(), 2, "Map size")
        assert_equals(map.get("key1"), Some("value1"), "Get value")
    })
    
    it("should handle map operations", || {
        let mut scores = HashMap::new()
        scores.insert("Alice", 100)
        scores.insert("Bob", 90)
        scores.insert("Charlie", 95)
        
        assert(scores.contains_key("Alice"), "Contains key")
        assert_equals(scores.remove("Bob"), Some(90), "Remove returns value")
        assert_equals(scores.len(), 2, "Size after remove")
    })
    
    it("should iterate over maps", || {
        let mut map = HashMap::new()
        map.insert(1, "one")
        map.insert(2, "two")
        map.insert(3, "three")
        
        let keys = map.keys().collect()
        assert_equals(keys.len(), 3, "Number of keys")
        
        let values = map.values().collect()
        assert_equals(values.len(), 3, "Number of values")
    })
})

describe("Structs and Objects", || {
    it("should create struct-like objects", || {
        let person = {
            name: "Alice",
            age: 30,
            email: "alice@example.com"
        }
        
        assert_equals(person.name, "Alice", "Access name field")
        assert_equals(person.age, 30, "Access age field")
    })
    
    it("should support nested structures", || {
        let company = {
            name: "TechCorp",
            employees: [
                { name: "Alice", role: "Developer" },
                { name: "Bob", role: "Designer" }
            ],
            founded: 2020
        }
        
        assert_equals(company.employees.len(), 2, "Employee count")
        assert_equals(company.employees[0].role, "Developer", "First employee role")
    })
})

describe("Tuples", || {
    it("should create and destructure tuples", || {
        let tuple = (1, "hello", true)
        assert_equals(tuple.0, 1, "First element")
        assert_equals(tuple.1, "hello", "Second element")
        assert_equals(tuple.2, true, "Third element")
    })
    
    it("should support tuple pattern matching", || {
        let point = (3, 4)
        let (x, y) = point
        assert_equals(x, 3, "X coordinate")
        assert_equals(y, 4, "Y coordinate")
        
        let distance = ((x * x + y * y) as f64).sqrt()
        assert_equals(distance, 5.0, "Distance from origin")
    })
})

describe("Options and Results", || {
    it("should handle Option type", || {
        let some_value = Some(42)
        let none_value = None
        
        assert(some_value.is_some(), "Some is some")
        assert(none_value.is_none(), "None is none")
        
        assert_equals(some_value.unwrap_or(0), 42, "Unwrap Some")
        assert_equals(none_value.unwrap_or(0), 0, "Unwrap None with default")
    })
    
    it("should handle Result type", || {
        fun divide(a, b) {
            if b == 0 {
                Err("Division by zero")
            } else {
                Ok(a / b)
            }
        }
        
        let result1 = divide(10, 2)
        assert(result1.is_ok(), "Valid division is Ok")
        assert_equals(result1.unwrap(), 5, "Division result")
        
        let result2 = divide(10, 0)
        assert(result2.is_err(), "Division by zero is Err")
    })
})

describe("Iterators", || {
    it("should chain iterator operations", || {
        let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        
        let result = nums.iter()
            .filter(|x| x % 2 == 0)
            .map(|x| x * 2)
            .sum()
        
        assert_equals(result, 60, "Sum of doubled evens: 4+8+12+16+20")
    })
    
    it("should support iterator methods", || {
        let data = [1, 2, 3, 4, 5]
        
        assert(data.iter().all(|x| x > 0), "All positive")
        assert(data.iter().any(|x| x == 3), "Contains 3")
        
        let max = data.iter().max()
        assert_equals(max, 5, "Maximum value")
        
        let min = data.iter().min()
        assert_equals(min, 1, "Minimum value")
    })
    
    it("should handle enumeration", || {
        let items = ["a", "b", "c"]
        let enumerated = items.iter().enumerate().collect()
        
        assert_equals(enumerated.len(), 3, "Enumerated length")
        assert_equals(enumerated[0], (0, "a"), "First enumerated")
        assert_equals(enumerated[2], (2, "c"), "Last enumerated")
    })
})

describe("Sets", || {
    it("should create and use sets", || {
        let mut set = HashSet::new()
        set.insert(1)
        set.insert(2)
        set.insert(3)
        set.insert(2) // Duplicate
        
        assert_equals(set.len(), 3, "Set ignores duplicates")
        assert(set.contains(2), "Set contains 2")
    })
    
    it("should perform set operations", || {
        let set1 = HashSet::from([1, 2, 3])
        let set2 = HashSet::from([2, 3, 4])
        
        let intersection = set1.intersection(&set2).collect()
        assert_equals(intersection.len(), 2, "Intersection size")
        
        let union = set1.union(&set2).collect()
        assert_equals(union.len(), 4, "Union size")
        
        let difference = set1.difference(&set2).collect()
        assert_equals(difference.len(), 1, "Difference size")
    })
})

describe("Deques", || {
    it("should use double-ended queue", || {
        let mut deque = VecDeque::new()
        deque.push_back(1)
        deque.push_back(2)
        deque.push_front(0)
        
        assert_equals(deque.len(), 3, "Deque size")
        assert_equals(deque.front(), Some(0), "Front element")
        assert_equals(deque.back(), Some(2), "Back element")
        
        assert_equals(deque.pop_front(), Some(0), "Pop front")
        assert_equals(deque.pop_back(), Some(2), "Pop back")
        assert_equals(deque.len(), 1, "Size after pops")
    })
})

describe("Binary Trees", || {
    it("should implement binary tree operations", || {
        // Simple binary tree node
        fun create_node(value, left, right) {
            { value: value, left: left, right: right }
        }
        
        let tree = create_node(5,
            create_node(3, 
                create_node(1, None, None),
                create_node(4, None, None)
            ),
            create_node(8,
                create_node(6, None, None),
                create_node(10, None, None)
            )
        )
        
        assert_equals(tree.value, 5, "Root value")
        assert_equals(tree.left.value, 3, "Left child")
        assert_equals(tree.right.value, 8, "Right child")
        
        // Tree traversal
        fun count_nodes(node) {
            if node.is_none() { 0 }
            else { 1 + count_nodes(node.left) + count_nodes(node.right) }
        }
        
        assert_equals(count_nodes(Some(tree)), 7, "Total nodes in tree")
    })
})

describe("Linked Lists", || {
    it("should implement linked list", || {
        // Node structure
        fun create_list_node(value, next) {
            { value: value, next: next }
        }
        
        // Create linked list: 1 -> 2 -> 3
        let list = create_list_node(1,
            Some(create_list_node(2,
                Some(create_list_node(3, None))
            ))
        )
        
        // Traverse and count
        fun list_length(node) {
            if node.is_none() { 0 }
            else { 1 + list_length(node.next) }
        }
        
        assert_equals(list_length(Some(list)), 3, "List length")
        assert_equals(list.value, 1, "First value")
        assert_equals(list.next.unwrap().value, 2, "Second value")
    })
})

describe("Graphs", || {
    it("should represent graphs with adjacency list", || {
        // Graph as adjacency list
        let graph = {
            "A": ["B", "C"],
            "B": ["A", "D"],
            "C": ["A", "D"],
            "D": ["B", "C"]
        }
        
        assert_equals(graph["A"].len(), 2, "A has 2 neighbors")
        assert_contains(graph["A"], "B", "A connects to B")
        assert_contains(graph["D"], "C", "D connects to C")
        
        // Count total edges
        let total_edges = graph.values()
            .map(|neighbors| neighbors.len())
            .sum() / 2  // Undirected graph
        
        assert_equals(total_edges, 4, "Total edges in graph")
    })
})

describe("Priority Queues", || {
    it("should implement priority queue behavior", || {
        // Simple priority queue using sorted array
        let mut pq = []
        
        fun insert_with_priority(queue, item, priority) {
            queue.push((priority, item))
            queue.sort_by(|a, b| a.0.cmp(&b.0))
            queue
        }
        
        fun pop_highest_priority(queue) {
            if queue.is_empty() { None }
            else { Some(queue.pop().1) }
        }
        
        pq = insert_with_priority(pq, "low", 3)
        pq = insert_with_priority(pq, "high", 1)
        pq = insert_with_priority(pq, "medium", 2)
        
        assert_equals(pop_highest_priority(pq), Some("high"), "Highest priority")
        assert_equals(pop_highest_priority(pq), Some("medium"), "Next priority")
        assert_equals(pop_highest_priority(pq), Some("low"), "Lowest priority")
    })
})

describe("Trie (Prefix Tree)", || {
    it("should implement trie for prefix matching", || {
        // Simple trie node
        fun create_trie_node() {
            { children: HashMap::new(), is_end: false }
        }
        
        fun insert_word(root, word) {
            let mut current = root
            for char in word.chars() {
                if !current.children.contains_key(char) {
                    current.children.insert(char, create_trie_node())
                }
                current = current.children.get(char).unwrap()
            }
            current.is_end = true
        }
        
        fun search_word(root, word) {
            let mut current = root
            for char in word.chars() {
                if !current.children.contains_key(char) {
                    return false
                }
                current = current.children.get(char).unwrap()
            }
            current.is_end
        }
        
        let trie = create_trie_node()
        insert_word(trie, "cat")
        insert_word(trie, "car")
        insert_word(trie, "card")
        
        assert(search_word(trie, "cat"), "Found 'cat'")
        assert(search_word(trie, "car"), "Found 'car'")
        assert(!search_word(trie, "ca"), "'ca' is not a complete word")
        assert(search_word(trie, "card"), "Found 'card'")
    })
})

// Run the test report
test_report()