// Test suite for function REPL demos
import { assert, assert_equals, assert_throws, describe, it, test_report } from "./test_framework.ruchy"

describe("Basic Functions", || {
    it("should define and call functions", || {
        fun greet(name) {
            "Hello, " + name + "!"
        }
        assert_equals(greet("Ruchy"), "Hello, Ruchy!", "Greeting function")
        assert_equals(greet("World"), "Hello, World!", "Greeting function with different input")
    })
    
    it("should handle function parameters", || {
        fun add(a, b) {
            a + b
        }
        assert_equals(add(5, 3), 8, "Addition function")
        assert_equals(add(100, 200), 300, "Addition with larger numbers")
    })
    
    it("should return values", || {
        fun square(x) {
            x * x
        }
        assert_equals(square(5), 25, "Square of 5")
        assert_equals(square(12), 144, "Square of 12")
    })
})

describe("Recursive Functions", || {
    it("should calculate factorial", || {
        fun factorial(n) {
            if n <= 1 { 
                1 
            } else { 
                n * factorial(n - 1) 
            }
        }
        assert_equals(factorial(5), 120, "5! should be 120")
        assert_equals(factorial(10), 3628800, "10! should be 3628800")
    })
    
    it("should calculate fibonacci", || {
        fun fibonacci(n) {
            if n <= 1 {
                n
            } else {
                fibonacci(n - 1) + fibonacci(n - 2)
            }
        }
        assert_equals(fibonacci(10), 55, "10th fibonacci number")
        assert_equals(fibonacci(15), 610, "15th fibonacci number")
    })
})

describe("Closures", || {
    it("should capture variables", || {
        let x = 10
        let add_x = |y| x + y
        assert_equals(add_x(5), 15, "Closure should capture x=10")
        assert_equals(add_x(20), 30, "Closure with different input")
    })
    
    it("should create counter closures", || {
        fun make_counter() {
            let mut count = 0
            || {
                count = count + 1
                count
            }
        }
        
        let counter1 = make_counter()
        assert_equals(counter1(), 1, "First call should return 1")
        assert_equals(counter1(), 2, "Second call should return 2")
        assert_equals(counter1(), 3, "Third call should return 3")
    })
})

describe("Higher-Order Functions", || {
    it("should pass functions as parameters", || {
        fun apply_twice(f, x) {
            f(f(x))
        }
        
        fun increment(x) {
            x + 1
        }
        
        assert_equals(apply_twice(increment, 5), 7, "Applying increment twice to 5")
    })
    
    it("should return functions", || {
        fun make_multiplier(n) {
            |x| x * n
        }
        
        let times_two = make_multiplier(2)
        let times_five = make_multiplier(5)
        
        assert_equals(times_two(10), 20, "10 * 2 = 20")
        assert_equals(times_five(10), 50, "10 * 5 = 50")
    })
    
    it("should map over arrays", || {
        fun map_array(arr, f) {
            arr.map(f)
        }
        
        let numbers = [1, 2, 3, 4, 5]
        let doubled = map_array(numbers, |x| x * 2)
        assert_equals(doubled[0], 2, "First element doubled")
        assert_equals(doubled[4], 10, "Last element doubled")
    })
})

describe("Function Composition", || {
    it("should compose functions", || {
        fun compose(f, g) {
            |x| g(f(x))
        }
        
        fun add_one(x) {
            x + 1
        }
        
        fun double(x) {
            x * 2
        }
        
        let add_then_double = compose(add_one, double)
        assert_equals(add_then_double(5), 12, "(5 + 1) * 2 = 12")
        
        let double_then_add = compose(double, add_one)
        assert_equals(double_then_add(5), 11, "(5 * 2) + 1 = 11")
    })
    
    it("should handle multiple composition", || {
        fun compose(f, g) {
            |x| g(f(x))
        }
        
        fun add_one(x) { x + 1 }
        fun double(x) { x * 2 }
        fun triple(x) { x * 3 }
        
        let complex = compose(compose(add_one, double), triple)
        assert_equals(complex(5), 36, "((5 + 1) * 2) * 3 = 36")
    })
})

describe("Partial Application", || {
    it("should partially apply functions", || {
        fun add(a, b) {
            a + b
        }
        
        fun partial(f, a) {
            |b| f(a, b)
        }
        
        let add5 = partial(add, 5)
        assert_equals(add5(3), 8, "5 + 3 = 8")
        assert_equals(add5(10), 15, "5 + 10 = 15")
    })
})

describe("Variadic Functions", || {
    it("should handle variable arguments", || {
        fun sum(nums) {
            nums.iter().sum()
        }
        assert_equals(sum([1, 2, 3, 4, 5]), 15, "Sum of 1..5")
        assert_equals(sum([10, 20]), 30, "Sum of 10, 20")
    })
})

describe("Function Chaining", || {
    it("should chain function calls", || {
        fun chain_start(value) {
            {
                value: value,
                add: |n| chain_start(value + n),
                multiply: |n| chain_start(value * n),
                get: || value
            }
        }
        
        let result = chain_start(5)
            .add(3)
            .multiply(2)
            .add(10)
            .get()
        
        assert_equals(result, 26, "(5 + 3) * 2 + 10 = 26")
    })
})

// Run the test report
test_report()