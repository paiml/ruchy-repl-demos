// Unsafe Rust patterns and FFI in Ruchy

// Basic operations
fun basic_unsafe_operations() {
    println!("=== Basic Unsafe Operations ===");
    
    // Raw pointers
    let x = 42;
    let raw_ptr = x as *i32;
    let const_raw_ptr = &x as *const i32;
    
    println!("Raw pointer address: {:p}", raw_ptr);
    println!("Const raw pointer address: {:p}", const_raw_ptr);
    
    // Dereferencing raw pointers requires unsafe
    {
        println!("Value through raw pointer: {}", *raw_ptr);
        *raw_ptr = 100;
        println!("Modified value: {}", *raw_ptr);
    }
    
    println!("Original variable: {}", x);
}

basic_unsafe_operations();

// Working with uninitialized memory
use std::mem::MaybeUninit;

fun uninitialized_memory_example() {
    println!("\n=== Uninitialized Memory ===");
    
    // Safe way to work with uninitialized memory
    let array: [MaybeUninit<i32>; 5] = {
        MaybeUninit::uninit().assume_init()
    };
    
    // Initialize elements
    for (i, elem) in array.iter_mut().enumerate() {
        elem.write(i as i32 * 10);
    }
    
    // Convert to initialized array
    let initialized_array: [i32; 5] = {
        std::mem::transmute(array)
    };
    
    println!("Initialized array: {:?}", initialized_array);
    
    // Alternative safer approach
    let safe_array = with_capacity(5);
    for i in 0..5 {
        safe_array.push(i * 10);
    }
    println!("Safe array: {:?}", safe_array);
}

uninitialized_memory_example();

// Transmutation and type casting
fun transmutation_examples() {
    println!("\n=== Transmutation Examples ===");
    
    // Transmute between compatible types
    let float_bits = {
        std::mem::transmute(3.14f32)
    };
    println!("Float 3.14 as u32 bits: 0x{:08x}", float_bits);
    
    let back_to_float = {
        std::mem::transmute(float_bits)
    };
    println!("Back to float: {}", back_to_float);
    
    // Transmute array to different type
    let bytes = [1u8, 2, 3, 4];
    let as_u32 = {
        std::mem::transmute(bytes)
    };
    println!("Bytes {:?} as u32: {}", bytes, as_u32);
    
    // Union for safe transmutation alternative
    union FloatOrInt {
        f,
        i,
    }
    
    let union_val = FloatOrInt { f: 2.718 };
    {
        println!("Union float: {}, as int: 0x{:08x}", union_val.f, union_val.i);
    }
}

transmutation_examples();

// Manual memory management
fun manual_memory_management() {
    println!("\n=== Manual Memory Management ===");
    
    use std::alloc::{alloc, dealloc, Layout};
    
    {
        // Allocate memory for 10 integers
        let layout = Layout::array::<i32>(10).unwrap();
        let ptr = alloc(layout) as *i32;
        
        if ptr.is_null() {
            panic!("Failed to allocate memory");
        }
        
        // Initialize the memory
        for i in 0..10 {
            ptr.add(i).write(i as i32);
        }
        
        // Read back the values
        print!("Manually allocated array: [");
        for i in 0..10 {
            if i > 0 { print!(", "); }
            print!("{}", ptr.add(i).read());
        }
        println!("]");
        
        // IMPORTANT deallocate manually
        dealloc(ptr as *u8, layout);
    }
    
    println!("Memory deallocated successfully");
}

manual_memory_management();

// Unsafe traits and implementations
UnsafeTrait {
    fun dangerous_method(&self);
}

SafeStruct {
    value,
}

UnsafeTrait for SafeStruct {
    fun dangerous_method(&self) {
        println!("Performing dangerous operation with value: {}", self.value);
    }
}

fun unsafe_traits_example() {
    println!("\n=== Unsafe Traits ===");
    
    let safe_= SafeStruct { value: 42 };
    safe_struct.dangerous_method();
}

unsafe_traits_example();

// Send and Sync marker traits
use std::sync::Arc;
use std::thread;

#[derive(Debug)]
NotSendSync {
    ptr: *const u8,
}

// Manually implement Send and Sync (DANGEROUS - only do if you know what you're doing)
Send for NotSendSync {}
Sync for NotSendSync {}

fun send_sync_example() {
    println!("\n=== Send and Sync Traits ===");
    
    let data = Arc::new(NotSendSync {
        ptr::ptr::null(),
    });
    
    let handles = (0..3)
        .map(|i| {
            let data_clone = Arc::clone(&data);
            thread::spawn(move || {
                println!("Thread {}: {:?}", i, data_clone);
            })
        })
        .collect();
    
    for handle in handles {
        handle.join().unwrap();
    }
}

send_sync_example();

// Foreign Function Interface (FFI)
extern "C" {
    fun abs(input);
    fun strlen(s: *const i8);
}

fun ffi_example() {
    println!("\n=== Foreign Function Interface ===");
    
    {
        let result = abs(-42);
        println!("abs(-42) = {}", result);
        
        // Working with C strings
        let c_string = std::ffi::CString::new("Hello, FFI!").unwrap();
        let c_str_ptr = c_string.as_ptr();
        let length = strlen(c_str_ptr);
        println!("C string length: {}", length);
    }
}

ffi_example();

// Inline assembly (platform-specific)
#[cfg(target_arch = "x86_64")]
fun inline_assembly_example() {
    println!("\n=== Inline Assembly (x86_64) ===");
    
    {
        let result;
        std::arch::asm!(
            "mov {}, 42",
            out(reg) result,
        );
        println!("Assembly result: {}", result);
        
        // Simple addition in assembly
        let a = 10;
        let b = 20;
        let sum;
        
        std::arch::asm!(
            "add {result}, {a}",
            a = in(reg) a,
            result = inout(reg) b => sum,
        );
        
        println!("Assembly addition: {} + {} = {}", a, b, sum);
    }
}

#[cfg(not(target_arch = "x86_64"))]
fun inline_assembly_example() {
    println!("\n=== Inline Assembly ===");
    println!("Inline assembly example only available on x86_64");
}

inline_assembly_example();

// Unsafe cell for interior mutability
use std::cell::UnsafeCell;

CustomCell {
    value,
}

CustomCell {
    fun new(value) -> Self {
        CustomCell {
            value::new(value),
        }
    }
    
    fun get(&self) -> *T {
        self.value.get()
    }
    
    fun set(&self, value) {
        {
            *self.get() = value;
        }
    }
    
    fun read(&self) -> T
    where
        T,
    {
        { *self.get() }
    }
}

impl<T> Sync for CustomCell {}

fun unsafe_cell_example() {
    println!("\n=== UnsafeCell Example ===");
    
    let cell = CustomCell::new(42);
    println!("Initial value: {}", cell.read());
    
    cell.set(100);
    println!("After set: {}", cell.read());
    
    // Demonstrate shared mutable access (DANGEROUS!)
    {
        let ptr1 = cell.get();
        let ptr2 = cell.get();
        
        *ptr1 = 200;
        println!("Modified through ptr1: {}", *ptr2);
    }
}

unsafe_cell_example();

// Global mutable state
static GLOBAL_COUNTER = 0;

fun modify_global_state() {
    {
        GLOBAL_COUNTER += 1;
        println!("Global counter: {}", GLOBAL_COUNTER);
    }
}

fun global_state_example() {
    println!("\n=== Global Mutable State ===");
    
    for _ in 0..5 {
        modify_global_state();
    }
    
    // Better alternative Mutex or atomic types
    use std::sync::atomic::{AtomicI32, Ordering};
    
    static ATOMIC_COUNTER = AtomicI32::new(0);
    
    for _ in 0..5 {
        let old_value = ATOMIC_COUNTER.fetch_add(1, Ordering::SeqCst);
        println!("Atomic counter (old value): {}", old_value);
    }
    
    println!("Final atomic counter value: {}", ATOMIC_COUNTER.load(Ordering::SeqCst));
}

global_state_example();

// Unsafe function and calling conventions
fun unsafe_function(ptr: *i32) {
    if !ptr.is_null() {
        *ptr = 42;
    }
}

extern "C" fun c_callable_function(x) {
    x * 2
}

fun unsafe_functions_example() {
    println!("\n=== Unsafe Functions ===");
    
    let value = 0;
    let ptr = value as *i32;
    
    {
        unsafe_function(ptr);
    }
    
    println!("Value after function: {}", value);
    
    // Function pointer
    let fn_ptr "C" fun(i32) = c_callable_function;
    let result = fn_ptr(21);
    println!("C callable function result: {}", result);
}

unsafe_functions_example();

println!("\n=== Unsafe Rust Examples Complete ===");
println!("Remember only when necessary and always verify safety invariants!")