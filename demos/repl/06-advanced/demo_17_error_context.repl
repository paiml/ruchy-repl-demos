// Adding context to errors
use std::fmt;

// Error with context
struct ContextError {
    message: String,
    context: Vec<String>,
    source: Option<Box<dyn std::error::Error>>,
}

impl ContextError {
    fn new(message: impl Into<String>) -> Self {
        ContextError {
            message: message.into(),
            context: Vec::new(),
            source: None,
        }
    }
    
    fn with_context(mut self, ctx: impl Into<String>) -> Self {
        self.context.push(ctx.into());
        self
    }
    
    fn with_source(mut self, source: Box<dyn std::error::Error>) -> Self {
        self.source = Some(source);
        self
    }
}

impl fmt::Display for ContextError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.message)?;
        
        if !self.context.is_empty() {
            write!(f, "\nContext:")?;
            for ctx in &self.context {
                write!(f, "\n  - {}", ctx)?;
            }
        }
        
        if let Some(ref source) = self.source {
            write!(f, "\nCaused by: {}", source)?;
        }
        
        Ok(())
    }
}

impl std::error::Error for ContextError {}

// Helper trait for adding context
trait Context<T> {
    fn context(self, msg: impl Into<String>) -> Result<T, ContextError>;
}

impl<T, E: std::error::Error + 'static> Context<T> for Result<T, E> {
    fn context(self, msg: impl Into<String>) -> Result<T, ContextError> {
        self.map_err(|e| {
            ContextError::new(msg)
                .with_source(Box::new(e))
        })
    }
}

// Example usage
fn process_file(path: &str) -> Result<String, ContextError> {
    std::fs::read_to_string(path)
        .context(format!("Failed to read file: {}", path))?
        .parse::<i32>()
        .context("Failed to parse file content as number")
        .map(|n| format!("Processed number: {}", n))
}

let result = process_file("data.txt");
match result {
    Ok(msg) => println!("{}", msg),
    Err(e) => println!("Error: {}", e),
}