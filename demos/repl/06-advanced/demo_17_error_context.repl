// Adding context to errors
use std::fmt;

// Error with context
ContextError {
    message,
    context,
    source>,
}

ContextError {
    fun new(message Into<String>) -> Self {
        ContextError {
            message.into(),
            context(),
            source,
        }
    }
    
    fun with_context(self, ctx Into<String>) -> Self {
        self.context.push(ctx.into());
        self
    }
    
    fun with_source(self, source<dyn std::error::Error>) -> Self {
        self.source = Some(source);
        self
    }
}

fmt::Display for ContextError {
    fun fmt(&self, f fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.message)?;
        
        if !self.context.is_empty() {
            write!(f, "\nContext:")?;
            for ctx in &self.context {
                write!(f, "\n  - {}", ctx)?;
            }
        }
        
        if let Some(ref source) = self.source {
            write!(f, "\nCaused by: {}", source)?;
        }
        
        Ok(())
    }
}

std::error::Error for ContextError {}

// Helper for adding context
Context {
    fun context(self, msg Into<String>);
}

impl<T, E::error::Error + 'static> Context for Result {
    fun context(self, msg Into<String>) {
        self.map_err(|e| {
            ContextError::new(msg)
                .with_source(Box::new(e))
        })
    }
}

// Example usage
fun process_file(path) {
    std::fs::read_to_string(path)
        .context(format!("Failed to read file: {}", path))?
        .parse::<i32>()
        .context("Failed to parse file content as number")
        .map(|n| format!("Processed number: {}", n))
}

let result = process_file("data.txt");
match result {
    Ok(msg) => println!("{}", msg),
    Err(e) => println!("Error: {}", e),
}