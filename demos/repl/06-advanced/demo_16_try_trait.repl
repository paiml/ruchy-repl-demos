// Try and custom types
use std::ops::Try;
use std::convert::Infallible;

// Custom Result-like type
Outcome {
    Success(T),
    Failure(E),
}

Outcome {
    fun is_success(&self) {
        matches!(self, Outcome::Success(_))
    }
    
    fun map(self, f) -> Outcome
    where F(T) -> U {
        match self {
            Outcome::Success(value) => Outcome::Success(f(value)),
            Outcome::Failure(err) => Outcome::Failure(err),
        }
    }
    
    fun and_then(self, f) -> Outcome
    where F(T) -> Outcome {
        match self {
            Outcome::Success(value) => f(value),
            Outcome::Failure(err) => Outcome::Failure(err),
        }
    }
}

// Conversion utilities
From for Outcome<T, Infallible> {
    fun from(value) -> Self {
        Outcome::Success(value)
    }
}

// Example usage
fun divide_outcome(x, y) , String> {
    if y == 0 {
        Outcome::Failure("Division by zero".to_string())
    } else {
        Outcome::Success(x / y)
    }
}

let result = divide_outcome(10, 2)
    .map(|x| x * 2)
    .and_then(|x| divide_outcome(x, 5));

match result {
    Outcome::Success(v) => println!("Final result: {}", v),
    Outcome::Failure(e) => println!("Error: {}", e),
}