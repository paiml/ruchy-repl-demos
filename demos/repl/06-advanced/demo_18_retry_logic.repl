// Retry logic for error recovery
use std::thread;
use std::time::Duration;

// Retry configuration
RetryConfig {
    max_attempts,
    delay_ms,
    exponential_backoff,
}

Default for RetryConfig {
    fun default() -> Self {
        RetryConfig {
            max_attempts: 3,
            delay_ms: 100,
            exponential_backoff,
        }
    }
}

// Retry function
fun retry(config, operation)
where
    F(),
    E::fmt::Display,
{
    let attempts = 0;
    let delay = config.delay_ms;
    
    loop {
        attempts += 1;
        
        match operation() {
            Ok(result) => return Ok(result),
            Err(e) if attempts >= config.max_attempts => {
                println!("Failed after {} attempts", attempts);
                return Err(e);
            }
            Err(e) => {
                println!("Attempt {} failed: {}", attempts, e);
                thread::sleep(Duration::from_millis(delay));
                
                if config.exponential_backoff {
                    delay *= 2;
                }
            }
        }
    }
}

// Simulated flaky operation
fun flaky_operation() {
    static COUNTER = 0;
    
    {
        COUNTER += 1;
        if COUNTER < 3 {
            Err("Service temporarily unavailable")
        } else {
            Ok("Success!".to_string())
        }
    }
}

// Using retry
let config = RetryConfig {
    max_attempts: 5,
    delay_ms: 50,
    exponential_backoff,
};

let result = retry(config, flaky_operation);
match result {
    Ok(msg) => println!("Final result: {}", msg),
    Err(e) => println!("Final error: {}", e),
}