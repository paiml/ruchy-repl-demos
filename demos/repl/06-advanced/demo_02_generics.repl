// Generic types and functions in Ruchy

// Generic function
fun swap(a, b) -> (T, T) {
    (b, a)
}

let (x, y) = swap(1, 2);
println!("Swapped integers: ({}, {})", x, y);

let (a, b) = swap("hello", "world");
println!("Swapped strings: ({}, {})", a, b);

// Generic struct
#[derive(Debug)]
Pair {
    first,
    second,
}

Pair {
    fun new(first, second) -> Self {
        Pair { first, second }
    }
    
    fun swap(self) -> Pair {
        Pair {
            first.second,
            second.first,
        }
    }
}

Pair
where
    T::fmt::Display,
{
    fun display(&self) {
        println!("Pair: ({}, {})", self.first, self.second);
    }
}

let int_pair = Pair::new(10, 20);
let string_pair = Pair::new("foo", "bar");

int_pair.display();
string_pair.display();

let swapped = int_pair.swap();
swapped.display();

// Multiple generic types
#[derive(Debug)]
Triple {
    first,
    second,
    third,
}

Triple {
    fun new(first, second, third) -> Self {
        Triple { first, second, third }
    }
    
    fun get_first(&self) -> &T {
        &self.first
    }
}

let mixed_triple = Triple::new(42, "hello", true);
println!("Mixed triple: {:?}", mixed_triple);
println!("First element: {}", mixed_triple.get_first());

// Generic enum
#[derive(Debug)]
Result {
    Ok(T),
    Err(E),
}

Result {
    fun is_ok(&self) {
        matches!(self, Ok(_))
    }
    
    fun is_err(&self) {
        matches!(self, Err(_))
    }
    
    fun map(self, f)
    where
        F(T) -> U,
    {
        match self {
            Ok(value) => Ok(f(value)),
            Err(error) => Err(error),
        }
    }
}

fun divide(a, b) {
    if b == 0.0 {
        Err("Division by zero".to_string())
    } else {
        Ok(a / b)
    }
}

let success = divide(10.0, 2.0);
let error = divide(10.0, 0.0);

println!("Division success: {:?}", success);
println!("Division error: {:?}", error);

let doubled = success.map(|x| x * 2.0);
println!("Doubled result: {:?}", doubled);

// Generic collections
#[derive(Debug)]
Stack {
    items,
}

Stack {
    fun new() -> Self {
        Stack { items() }
    }
    
    fun push(self, item) {
        self.items.push(item);
    }
    
    fun pop(self) {
        self.items.pop()
    }
    
    fun peek(&self) {
        self.items.last()
    }
    
    fun len(&self) {
        self.items.len()
    }
    
    fun is_empty(&self) {
        self.items.is_empty()
    }
}

let int_stack = Stack::new();
int_stack.push(1);
int_stack.push(2);
int_stack.push(3);

println!("Stack: {:?}", int_stack);
println!("Peek: {:?}", int_stack.peek());
println!("Pop: {:?}", int_stack.pop());
println!("Stack after pop: {:?}", int_stack);

// Generic with bounds
use std::cmp::PartialOrd;

fun find_max(slice)
where
    T,
{
    if slice.is_empty() {
        return None;
    }
    
    let max = &slice[0];
    for item in slice.iter().skip(1) {
        if item > max {
            max = item;
        }
    }
    Some(max)
}

let numbers = [3, 1, 4, 1, 5, 9, 2, 6];
let strings = ["apple", "zebra", "banana", "cherry"];

println!("Max number: {:?}", find_max(&numbers));
println!("Max string: {:?}", find_max(strings));

// Associated types
Iterator {
    fun next(self);
}

Counter {
    current,
    max,
}

Counter {
    fun new(max) -> Self {
        Counter { current: 0, max }
    }
}

Iterator<usize> for Counter {
    fun next(self) {
        if self.current < self.max {
            let result = self.current;
            self.current += 1;
            Some(result)
        } else {
            None
        }
    }
}

let counter = Counter::new(5);
while let Some(value) = counter.next() {
    println!("Counter: {}", value);
}

// Generic implementation
Drawable {
    fun draw(&self);
}

#[derive(Debug)]
Circle {
    radius,
}

#[derive(Debug)]
Rectangle {
    width,
    height,
}

Drawable for Circle
where
    T::fmt::Display,
{
    fun draw(&self) {
        println!("Drawing circle with radius: {}", self.radius);
    }
}

Drawable for Rectangle
where
    T::fmt::Display,
{
    fun draw(&self) {
        println!("Drawing rectangle {}x{}", self.width, self.height);
    }
}

let circle = Circle { radius: 5.0 };
let rectangle = Rectangle { width: 10, height: 20 };

circle.draw();
rectangle.draw()