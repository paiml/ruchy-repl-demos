// Advanced pattern matching in Ruchy

#[derive(Debug)]
enum Color {
    Red,
    Green,
    Blue,
    RGB(u8, u8, u8),
    HSV { h: f32, s: f32, v: f32 },
}

// Basic enum pattern matching
let colors = [
    Color::Red,
    Color::RGB(255, 0, 0),
    Color::HSV { h: 0.0, s: 1.0, v: 1.0 },
];

for color in colors {
    match color {
        Color::Red => println!("Primary red"),
        Color::Green => println!("Primary green"),
        Color::Blue => println!("Primary blue"),
        Color::RGB(r, g, b) => println!("RGB color: ({}, {}, {})", r, g, b),
        Color::HSV { h, s, v } => println!("HSV color: h={}, s={}, v={}", h, s, v),
    }
}

// Pattern matching with guards
fn classify_number(n: i32) -> String {
    match n {
        x if x < 0 => "Negative".to_string(),
        0 => "Zero".to_string(),
        1..=10 => "Small positive".to_string(),
        11..=100 => "Medium positive".to_string(),
        x if x % 2 == 0 => "Large even".to_string(),
        _ => "Large odd".to_string(),
    }
}

let numbers = [-5, 0, 3, 50, 200, 301];
for num in numbers {
    println!("{}: {}", num, classify_number(num));
}

// Destructuring tuples and structs
#[derive(Debug)]
struct Point3D {
    x: f64,
    y: f64,
    z: f64,
}

let points = [
    ((0, 0), Point3D { x: 1.0, y: 2.0, z: 3.0 }),
    ((1, 2), Point3D { x: 0.0, y: 0.0, z: 0.0 }),
    ((3, 4), Point3D { x: -1.0, y: 5.0, z: 2.0 }),
];

for (coord_2d, point_3d) in points {
    match (coord_2d, point_3d) {
        ((0, 0), Point3D { x: 0.0, y: 0.0, z: 0.0 }) => {
            println!("Origin point in both 2D and 3D");
        },
        ((0, 0), Point3D { x, y, z }) => {
            println!("2D origin, 3D point: ({}, {}, {})", x, y, z);
        },
        ((x, y), Point3D { x: 0.0, y: 0.0, z: 0.0 }) => {
            println!("2D point: ({}, {}), 3D origin", x, y);
        },
        ((x2d, y2d), Point3D { x: x3d, y: y3d, z: z3d }) => {
            println!("2D: ({}, {}), 3D: ({}, {}, {})", x2d, y2d, x3d, y3d, z3d);
        },
    }
}

// Nested pattern matching
#[derive(Debug)]
enum Shape {
    Circle(f64),
    Rectangle(f64, f64),
    Triangle(f64, f64, f64),
}

#[derive(Debug)]
enum Container {
    Empty,
    Single(Shape),
    Multiple(Vec<Shape>),
}

fn analyze_container(container: Container) -> String {
    match container {
        Container::Empty => "Empty container".to_string(),
        Container::Single(Shape::Circle(r)) if r > 5.0 => {
            format!("Large circle with radius {}", r)
        },
        Container::Single(Shape::Circle(r)) => {
            format!("Small circle with radius {}", r)
        },
        Container::Single(Shape::Rectangle(w, h)) => {
            format!("Rectangle {}x{}, area: {}", w, h, w * h)
        },
        Container::Single(shape) => {
            format!("Single shape: {:?}", shape)
        },
        Container::Multiple(shapes) if shapes.len() > 3 => {
            format!("Many shapes: {} total", shapes.len())
        },
        Container::Multiple(shapes) => {
            format!("Few shapes: {:?}", shapes)
        },
    }
}

let containers = [
    Container::Empty,
    Container::Single(Shape::Circle(3.0)),
    Container::Single(Shape::Circle(7.0)),
    Container::Single(Shape::Rectangle(4.0, 5.0)),
    Container::Multiple(vec![Shape::Circle(1.0), Shape::Triangle(3.0, 4.0, 5.0)]),
];

for container in containers {
    println!("{}", analyze_container(container));
}

// Pattern matching with Option and Result
fn process_maybe_number(opt_num: Option<i32>) -> String {
    match opt_num {
        Some(n) if n % 2 == 0 => format!("Even number: {}", n),
        Some(n) if n < 0 => format!("Negative number: {}", n),
        Some(n) => format!("Odd positive number: {}", n),
        None => "No number provided".to_string(),
    }
}

let maybe_numbers = [Some(4), Some(-3), Some(7), None];
for maybe_num in maybe_numbers {
    println!("{}", process_maybe_number(maybe_num));
}

// Advanced array/slice pattern matching
fn analyze_sequence(seq: &[i32]) -> String {
    match seq {
        [] => "Empty sequence".to_string(),
        [x] => format!("Single element: {}", x),
        [x, y] => format!("Two elements: {}, {}", x, y),
        [first, middle @ .., last] => {
            format!("First: {}, Middle: {:?}, Last: {}", first, middle, last)
        },
    }
}

let sequences = [
    &[][..],
    &[42][..],
    &[1, 2][..],
    &[1, 2, 3, 4, 5][..],
];

for seq in sequences {
    println!("{:?}: {}", seq, analyze_sequence(seq));
}