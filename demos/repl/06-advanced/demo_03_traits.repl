// Traits and implementations in Ruchy

// Basic definition
Describable {
    fun describe(&self);
}

#[derive(Debug)]
Person {
    name,
    age,
}

#[derive(Debug)]
Book {
    title,
    author,
    pages,
}

// Implementing for different types
Describable for Person {
    fun describe(&self) {
        format!("Person: {} is {} years old", self.name, self.age)
    }
}

Describable for Book {
    fun describe(&self) {
        format!("Book: '{}' by {} ({} pages)", self.title, self.author, self.pages)
    }
}

let person = Person {
    name: "Alice".to_string(),
    age: 30,
};

let book = Book {
    title: "The Rust Book".to_string(),
    author: "Steve Klabnik".to_string(),
    pages: 500,
};

println!("{}", person.describe());
println!("{}", book.describe());

// Trait with default implementation
Greetings {
    fun hello(&self) {
        "Hello!".to_string()
    }
    
    fun goodbye(&self) {
        "Goodbye!".to_string()
    }
    
    fun name(&self);
    
    fun full_greeting(&self) {
        format!("{} I'm {}. {}", self.hello(), self.name(), self.goodbye())
    }
}

Greetings for Person {
    fun name(&self) {
        self.name.clone()
    }
    
    // Override default hello
    fun hello(&self) {
        "Hi there!".to_string()
    }
}

println!("{}", person.full_greeting());

// Trait with associated types
Container {
    type Item;
    
    fun add(self, item::Item);
    fun remove(self);
    fun len(&self);
}

NumberContainer {
    numbers,
}

Container for NumberContainer {
    type Item = i32;
    
    fun add(self, item::Item) {
        self.numbers.push(item);
    }
    
    fun remove(self) {
        self.numbers.pop()
    }
    
    fun len(&self) {
        self.numbers.len()
    }
}

let container = NumberContainer { numbers() };
container.add(1);
container.add(2);
container.add(3);

println!("Container length: {}", container.len());
println!("Removed: {:?}", container.remove());
println!("Container length after removal: {}", container.len());

// Multiple bounds
Printable {
    fun print(&self);
}

Cloneable {
    fun clone_me(&self) -> Self;
}

Printable for i32 {
    fun print(&self) {
        println!("Integer: {}", self);
    }
}

Cloneable for i32 {
    fun clone_me(&self) -> Self {
        *self
    }
}

fun process_item(item) -> T
where
    T + Cloneable,
{
    item.print();
    item.clone_me()
}

let number = 42;
let cloned = process_item(&number);
println!("Original: {}, Cloned: {}", number, cloned);

// Trait objects (dynamic dispatch)
fun describe_all(items) {
    for item in items {
        println!("{}", item.describe());
    }
}

let items = [&person, &book];
describe_all(items);

// Generic with constraints
Comparable {
    fun is_greater_than(&self, other);
}

Comparable<Person> for Person {
    fun is_greater_than(&self, other) {
        self.age > other.age
    }
}

let person1 = Person { name: "Alice".to_string(), age: 30 };
let person2 = Person { name: "Bob".to_string(), age: 25 };

println!("Alice older than Bob: {}", person1.is_greater_than(&person2));

// Operator overloading through traits
use std::ops::Add;

#[derive(Debug, Clone, Copy)]
Point {
    x,
    y,
}

Add for Point {
    type Output = Point;
    
    fun add(self, other) -> Point {
        Point {
            x.x + other.x,
            y.y + other.y,
        }
    }
}

let p1 = Point { x: 1.0, y: 2.0 };
let p2 = Point { x: 3.0, y: 4.0 };
let p3 = p1 + p2;

println!("Point addition: {:?} + {:?} = {:?}", p1, p2, p3);

// Marker traits
Serializable {}

Serializable for Person {}
Serializable for Book {}

fun serialize<T>(item) {
    "Serialized data".to_string() // Placeholder
}

println!("Serialized person: {}", serialize(&person));
println!("Serialized book: {}", serialize(&book));

// Trait with generic methods
Transformer {
    fun transform(&self, value, f) -> T
    where
        F(T) -> T;
}

Processor;

Transformer for Processor {
    fun transform(&self, value, f) -> T
    where
        F(T) -> T,
    {
        f(value)
    }
}

let processor = Processor;
let doubled = processor.transform(5, |x| x * 2);
let uppercased = processor.transform("hello".to_string(), |s| s.to_uppercase());

println!("Transformed number: {}", doubled);
println!("Transformed string: {}", uppercased)