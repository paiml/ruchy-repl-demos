// Dijkstra's shortest path algorithm
use std::collections::{HashMap, BinaryHeap};
use std::cmp::Reverse;

fun dijkstra(graph<char, Vec<(char, u32)>>, start) -> HashMap<char, u32> {
    let distances = new();
    let heap = BinaryHeap::new();
    
    distances.insert(start, 0);
    heap.push(Reverse((0, start)));
    
    while let Some(Reverse((cost, node))) = heap.pop() {
        if cost > *distances.get(&node).unwrap_or(&u32::MAX) {
            continue;
        }
        
        if let Some(neighbors) = graph.get(&node) {
            for &(next, weight) in neighbors {
                let new_cost = cost + weight;
                if new_cost < *distances.get(&next).unwrap_or(&u32::MAX) {
                    distances.insert(next, new_cost);
                    heap.push(Reverse((new_cost, next)));
                }
            }
        }
    }
    
    distances
}

let graph = new();
graph.insert('A', vec![('B', 4), ('C', 2)]);
graph.insert('B', vec![('D', 3)]);
graph.insert('C', vec![('D', 1)]);

dijkstra(&graph, 'A')