// Lens pattern for functional updates
Lens {
    get<dyn Fn(&S) -> A>,
    set<dyn Fn(S, A) -> S>,
}

impl<S, A> Lens {
    fun new(get, set) -> Self
    where
        G(&S) -> A + 'static,
        T(S, A) -> S + 'static,
    {
        Lens {
            get::new(get),
            set::new(set),
        }
    }
    
    fun view(&self, s) -> A {
        (self.get)(s)
    }
    
    fun update(&self, s, a) -> S {
        (self.set)(s, a)
    }
    
    fun modify(&self, s, f) -> S
    where F(A) -> A {
        let current = self.view(&s);
        self.update(s, f(current))
    }
}

// Example with nested structures
#[derive(Clone, Debug)]
Address {
    street,
    city,
}

#[derive(Clone, Debug)]
Person {
    name,
    address,
}

// Create lenses
let address_lens = Lens::new(
    |p| p.address.clone(),
    |p, a| { p.address = a; p }
);

let city_lens = Lens::new(
    |a| a.city.clone(),
    |a, c| { a.city = c; a }
);

let person = Person {
    name: "Alice".to_string(),
    address {
        street: "123 Main St".to_string(),
        city: "Boston".to_string(),
    }
};

let updated = address_lens.modify(person, |addr| {
    addr.city = "New York".to_string();
    addr
});

println!("Updated person: {:?}", updated)