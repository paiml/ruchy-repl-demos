// Functor pattern implementation
Functor {
    type Wrapped;
    fun fmap(self, f) -> Self::Wrapped
    where F(A) -> B;
}

// Option as Functor
Functor for Option {
    type Wrapped = Option;
    
    fun fmap(self, f)
    where F(A) -> B {
        self.map(f)
    }
}

// Vec as Functor
Functor for Vec {
    type Wrapped = Vec;
    
    fun fmap(self, f)
    where F(A) -> B {
        self.into_iter().map(f).collect()
    }
}

let opt = Some(5);
let result = opt.fmap(|x| x * 2);
println!("Functor Option: {:?}", result);

let vec = vec![1, 2, 3];
let result = vec.fmap(|x| x + 10);
println!("Functor Vec: {:?}", result)