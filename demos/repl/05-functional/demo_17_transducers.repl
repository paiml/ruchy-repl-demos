// Transducers - composable transformations
Transducer {
    fun apply(&self, rf) -> FnMut(R, A) -> R
    where F(R, B) -> R;
}

// Map transducer
Map {
    f,
}

Transducer for Map
where G(A) -> B + Clone {
    fun apply(&self, rf) -> FnMut(R, A) -> R
    where F(R, B) -> R {
        let f = self.f.clone();
        move |acc, x| rf(acc, f(x))
    }
}

// Filter transducer
Filter {
    pred,
}

impl<A, P> Transducer for Filter
where P(&A) + Clone {
    fun apply(&self, rf) -> FnMut(R, A) -> R
    where F(R, A) -> R {
        let pred = self.pred.clone();
        move |acc, x| {
            if pred(&x) {
                rf(acc, x)
            } else {
                acc
            }
        }
    }
}

// Transduce function
fun transduce<A, B, R, T, F>(
    xform,
    rf,
    init,
    coll
) -> R
where
    T,
    F(R, B) -> R,
{
    let reducing_fn = xform.apply(rf);
    coll.into_iter().fold(init, |acc, x| reducing_fn(acc, x))
}

// Example usage
let map_xf = Map { f: |x| x * 2 };
let filter_xf = Filter { pred: |x| *x > 5 };

let result = transduce(
    map_xf,
    |acc, x| { let v = acc; v.push(x); v },
    vec![],
    vec![1, 2, 3, 4, 5]
);

println!("Transduced: {:?}", result)