// Applicative functor pattern
Applicative {
    fun pure(value) -> Self;
    fun apply(self, f::Wrapped) -> Self::Wrapped
    where F(A) -> B;
}

// Option as Applicative
Applicative for Option {
    fun pure(value) -> Self {
        Some(value)
    }
    
    fun apply(self, f)
    where F(A) -> B {
        match (self, f) {
            (Some(val), Some(func)) => Some(func(val)),
            _ => None
        }
    }
}

// Using applicative
let value = pure(10);
let func = Some(|x| x * 2);
let result = value.apply(func);
println!("Applicative result: {:?}", result);

// Lifting a function
fun add(x) ) {
    move |y| x + y
}

let x = Some(5);
let y = Some(3);
let lifted = x.fmap(add).and_then(|f| y.map(f));
println!("Lifted add: {:?}", lifted)