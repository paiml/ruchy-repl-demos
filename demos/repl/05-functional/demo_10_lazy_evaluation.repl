// Lazy evaluation and infinite iterators in Ruchy

// Basic lazy iterator
fun fibonacci() -> Iterator<Item = u64> {
    let a = 0;
    let b = 1;
    
    std::iter::from_fn(move || {
        let current = a;
        let next = a + b;
        a = b;
        b = next;
        Some(current)
    })
}

// Take first 10 fibonacci numbers
let first_10_fib = fibonacci().take(10).collect();
println("First 10 Fibonacci numbers: {:?}", first_10_fib);

// Lazy evaluation with generators
fun infinite_primes() -> Iterator<Item = u64> {
    (2..).filter(|&n| is_prime(n))
}

fun is_prime(n) {
    if n < 2 { return false; }
    for i in 2..=((n as f64).sqrt() as u64) {
        if n % i == 0 { return false; }
    }
    true
}

// Take first 10 primes
let first_10_primes = infinite_primes().take(10).collect();
println("First 10 prime numbers: {:?}", first_10_primes);

// Lazy evaluation with custom iterator
PowersOfTwo {
    current,
}

PowersOfTwo {
    fun new() -> Self {
        PowersOfTwo { current: 1 }
    }
}

Iterator for PowersOfTwo {
    type Item = u64;
    
    fun next(self) {
        let result = self.current;
        self.current *= 2;
        Some(result)
    }
}

// Use lazy powers of two
let powers = PowersOfTwo::new().take(15).collect();
println("First 15 powers of 2: {:?}", powers);

// Lazy evaluation with complex transformations
fun natural_numbers() > {
    1..
}

// Complex lazy pipeline
let complex_result = natural_numbers()
    .filter(|&x| x % 2 == 0)  // Even numbers
    .map(|x| x * x)           // Square them
    .filter(|&x| x % 3 == 0)  // Divisible by 3
    .take(10)                 // First 10 results
    .collect();

println("Complex lazy evaluation result: {:?}", complex_result);

// Lazy evaluation with memoization
use std::cell::RefCell;
use std::collections::HashMap;

MemoizedIterator {
    generator,
    cache<HashMap<usize, T>>,
    index,
}

MemoizedIterator
where
    T,
    F(usize) -> T,
{
    fun new(generator) -> Self {
        MemoizedIterator {
            generator,
            cache::new(new()),
            index: 0,
        }
    }
}

Iterator for MemoizedIterator
where
    T,
    F(usize) -> T,
{
    type Item = T;
    
    fun next(self) {
        let cache = self.cache.borrow_mut();
        
        let result = if let Some(cached) = cache.get(&self.index) {
            cached.clone()
        } else {
            let computed = (self.generator)(self.index);
            cache.insert(self.index, computed.clone());
            computed
        };
        
        self.index += 1;
        Some(result)
    }
}

// Expensive computation with memoization
fun expensive_sequence(n) {
    println!("Computing expensive value for index {}", n);
    (n * n + n) as i32
}

let memoized_iter = MemoizedIterator::new(expensive_sequence);

// First iteration - computes values
let first_batch = memoized_iter.by_ref().take(5).collect();
println("First batch: {:?}", first_batch);

// Second iteration from same iterator - uses cached values where possible
let second_batch = memoized_iter.take(3).collect();
println("Second batch: {:?}", second_batch);

// Lazy evaluation with conditional logic
fun conditional_sequence() -> Iterator<Item = String> {
    (1..).map(|n| {
        if n % 15 == 0 {
            "FizzBuzz".to_string()
        } else if n % 3 == 0 {
            "Fizz".to_string()
        } else if n % 5 == 0 {
            "Buzz".to_string()
        } else {
            n.to_string()
        }
    })
}

let fizzbuzz = conditional_sequence().take(20).collect();
println("FizzBuzz sequence: {:?}", fizzbuzz);

// Infinite iterator composition
let composed_infinite = fibonacci()
    .zip(PowersOfTwo::new())
    .map(|(fib, pow)| fib + pow)
    .take(10)
    .collect();

println("Fibonacci + Powers of 2: {:?}", composed_infinite)