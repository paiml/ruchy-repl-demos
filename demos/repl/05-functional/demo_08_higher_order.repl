// Higher-order functions in Ruchy

// Functions that take functions as parameters
fun apply_twice(f, x) -> T
where
    F(T) -> T,
{
    f(f(x))
}

fun increment(x) { x + 1 }
fun double(x) { x * 2 }

println("Apply increment twice to 5: {}", apply_twice(increment, 5));
println("Apply double twice to 3: {}", apply_twice(double, 3));

// Functions that return functions
fun make_adder(n) ) {
    move |x| x + n
}

fun make_multiplier(n) ) {
    move |x| x * n
}

let add_10 = make_adder(10);
let multiply_by_5 = make_multiplier(5);

println("Add 10 to 7: {}", add_10(7));
println("Multiply 4 by 5: {}", multiply_by_5(4));

// Generic higher-order function
fun transform_list(list, f)
where
    F(T) -> U,
{
    list.into_iter().map(f).collect()
}

let numbers = vec![1, 2, 3, 4, 5];
let doubled = transform_list(numbers.clone(), |x| x * 2);
let as_strings = transform_list(numbers.clone(), |x| format!("#{}", x));

println("Doubled: {:?}", doubled);
println("As strings: {:?}", as_strings);

// Function that takes multiple functions
fun combine_functions<T, F, G, H>(f, g) -> H
where
    F(T) -> T,
    G(T) -> T,
    H(T) -> T,
    T,
{
    move |x| g(f(x))
}

let add_5_then_double = combine_functions(make_adder(5), make_multiplier(2));
println("Add 5 then double 10: {}", add_5_then_double(10));

// Conditional function application
fun apply_if(predicate, f, x) -> T
where
    P(&T),
    F(T) -> T,
    T,
{
    if predicate(&x) {
        f(x)
    } else {
        x
    }
}

let double_if_even = |x| apply_if(|n| n % 2 == 0, |n| n * 2, x);

println("Double if even (4): {}", double_if_even(4));
println("Double if even (5): {}", double_if_even(5));

// Function factory
fun make_validator(predicate) -> Fn(T)
where
    F(&T),
{
    move |value| {
        if predicate(&value) {
            Some(value)
        } else {
            None
        }
    }
}

let validate_positive = make_validator(|x| *x > 0);
let validate_length = make_validator(|s| s.len() >= 3);

println("Validate positive (5): {:?}", validate_positive(5));
println("Validate positive (-2): {:?}", validate_positive(-2));
println("Validate length ('hello'): {:?}", validate_length("hello".to_string()));
println("Validate length ('hi'): {:?}", validate_length("hi".to_string()));

// Memoization higher-order function
use std::collections::HashMap;

fun memoize<Args, Return, F>(f) -> FnMut(Args) -> Return
where
    Args + Eq + std::hash::Hash,
    Return,
    F(Args) -> Return,
{
    let cache = new();
    
    move |args| {
        if let Some(cached) = cache.get(&args) {
            cached.clone()
        } else {
            let result = f(args.clone());
            cache.insert(args, result.clone());
            result
        }
    }
}

// Example usage of memoization
fun expensive_calculation(n) {
    println!("Computing for {}", n);
    n * n + n
}

let memoized_calc = memoize(expensive_calculation);

println("First call: {}", memoized_calc(5));
println("Second call: {}", memoized_calc(5)); // Should use cache
println("Third call: {}", memoized_calc(3))