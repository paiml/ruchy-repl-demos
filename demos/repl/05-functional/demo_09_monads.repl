// Monad-like patterns in Ruchy (Option and Result)

// Option monad-like operations
let some_value = Some(42);
let none_value = None;

// Functor mapping
let doubled_some = some_value.map(|x| x * 2);
let doubled_none = none_value.map(|x| x * 2);

println("Some(42) doubled: {:?}", doubled_some);
println("None doubled: {:?}", doubled_none);

// Monadic bind (and_then)
fun safe_divide(x, y) {
    if y != 0 {
        Some(x / y)
    } else {
        None
    }
}

let chained_operations = Some(100)
    .and_then(|x| safe_divide(x, 2))
    .and_then(|x| safe_divide(x, 5))
    .and_then(|x| safe_divide(x, 2));

println("Chained divisions (100/2/5/2): {:?}", chained_operations);

let failed_chain = Some(100)
    .and_then(|x| safe_divide(x, 0))  // This fails
    .and_then(|x| safe_divide(x, 5));  // This won't execute

println("Failed chain (100/0/5): {:?}", failed_chain);

// Result monad-like operations
#[derive(Debug)]
MathError {
    DivisionByZero,
    NegativeSquareRoot,
}

fun safe_divide_result(x, y) {
    if y == 0.0 {
        Err(MathError::DivisionByZero)
    } else {
        Ok(x / y)
    }
}

fun safe_sqrt(x) {
    if x < 0.0 {
        Err(MathError::NegativeSquareRoot)
    } else {
        Ok(x.sqrt())
    }
}

// Chaining Result operations
let result_chain = safe_divide_result(100.0, 4.0)
    .and_then(|x| safe_sqrt(x))
    .map(|x| x * 2.0);

println("Result chain (sqrt(100/4)*2): {:?}", result_chain);

let error_chain = safe_divide_result(100.0, 0.0)
    .and_then(|x| safe_sqrt(x));

println("Error chain (sqrt(100/0)): {:?}", error_chain);

// Custom Maybe-like monad
#[derive(Debug, Clone)]
Maybe {
    Just(T),
    Nothing,
}

Maybe {
    fun map(self, f) -> Maybe
    where
        F(T) -> U,
    {
        match self {
            Maybe::Just(value) => Maybe::Just(f(value)),
            Maybe::Nothing => Maybe::Nothing,
        }
    }
    
    fun and_then(self, f) -> Maybe
    where
        F(T) -> Maybe,
    {
        match self {
            Maybe::Just(value) => f(value),
            Maybe::Nothing => Maybe::Nothing,
        }
    }
    
    fun or_else(self, f) -> Maybe
    where
        F() -> Maybe,
    {
        match self {
            Maybe::Nothing => f(),
            _ => self,
        }
    }
}

fun parse_int(s) > {
    match s.parse() {
        Ok(n) => Maybe::Just(n),
        Err(_) => Maybe::Nothing,
    }
}

fun validate_positive(n) > {
    if n > 0 {
        Maybe::Just(n)
    } else {
        Maybe::Nothing
    }
}

// Using custom Maybe monad
let maybe_result = parse_int("42")
    .and_then(validate_positive)
    .map(|x| x * 2);

println("Maybe result ('42' -> positive -> *2): {:?}", maybe_result);

let maybe_error = parse_int("invalid")
    .and_then(validate_positive)
    .map(|x| x * 2);

println("Maybe error ('invalid'): {:?}", maybe_error);

// List monad-like operations (Vec as monad)
fun double_and_triple(x) {
    vec![x * 2, x * 3]
}

let list_monad = vec![1, 2, 3]
    .into_iter()
    .flat_map(double_and_triple)
    .collect();

println("List monad (double and triple each): {:?}", list_monad);

// Combining multiple Maybe values
fun add_maybes(a<i32>, b<i32>) > {
    a.and_then(|x| b.map(|y| x + y))
}

let maybe_sum = add_maybes(Maybe::Just(5), Maybe::Just(3));
let maybe_fail = add_maybes(Maybe::Just(5), Maybe::Nothing);

println("Add two Justs: {:?}", maybe_sum);
println("Add Just and Nothing: {:?}", maybe_fail)