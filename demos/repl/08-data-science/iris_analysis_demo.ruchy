// REPL Demo: Iris Dataset Analysis - The Hello World of Data Science
// Dataset: Classic Fisher's Iris dataset (150 flowers, 4 measurements)  
// Skills: DataFrame operations, groupby, aggregation, statistical analysis
// INDUSTRY STANDARD: Using proper DataFrame syntax, not primitive arrays

println("=== Iris Dataset Analysis - Data Science with DataFrames ===");

// Create the famous Iris dataset using DataFrame (production: df.from_csv())
println("\n1. Loading the Iris Dataset as DataFrame:");
let iris_df = df![
    species => ["setosa", "setosa", "setosa", "setosa", "setosa",
                "versicolor", "versicolor", "versicolor", "versicolor", "versicolor",
                "virginica", "virginica", "virginica", "virginica", "virginica"],
    sepal_length => [5.1, 4.9, 4.7, 4.6, 5.0, 7.0, 6.4, 6.9, 5.5, 6.5, 6.3, 5.8, 7.1, 6.3, 6.5],
    sepal_width => [3.5, 3.0, 3.2, 3.1, 3.6, 3.2, 3.2, 3.1, 2.3, 2.8, 3.3, 2.7, 3.0, 2.9, 3.0],
    petal_length => [1.4, 1.4, 1.3, 1.5, 1.4, 4.7, 4.5, 4.9, 4.0, 4.6, 6.0, 5.1, 5.9, 5.6, 5.8],
    petal_width => [0.2, 0.2, 0.2, 0.2, 0.2, 1.4, 1.5, 1.5, 1.3, 1.5, 2.5, 1.9, 2.1, 1.8, 2.2]
];

println(f"✅ DataFrame loaded: {iris_df.height()} rows × {iris_df.width()} columns");
println(f"📊 Features: sepal_length, sepal_width, petal_length, petal_width, species");
println(f"🌸 Sample size: 15 flowers (subset of full 150-sample dataset)");

// 2. DataFrame Overview - Professional data science
println("\n2. DataFrame Overview:");
let species_counts = iris_df.groupby(["species"]).count();
println("Species distribution:");
println(species_counts);

// 3. Descriptive Statistics - DataFrame operations
println("\n3. Descriptive Statistics with DataFrames:");
let stats_summary = iris_df.select(["sepal_length", "petal_length"]).describe();
println("📈 Statistical Summary:");
println(stats_summary);

// Manual calculation for demonstration
let sepal_stats = iris_df.select(["sepal_length"]).agg([
    mean("sepal_length").alias("avg_sepal"),
    min("sepal_length").alias("min_sepal"),
    max("sepal_length").alias("max_sepal")
]);
println(f"\n📊 Sepal Length Statistics:");
println(sepal_stats);
println(f"  Average: {avg_sepal_length:.2f} cm");
println(f"  Range: {min_sepal_length:.1f} - {max_sepal_length:.1f} cm");

let petal_lengths = iris.map(|row| row.petal_length);
let avg_petal_length = petal_lengths.sum() / petal_lengths.len();
println(f"Petal Length Average: {avg_petal_length:.2f} cm");

// 4. Species-specific Analysis - Professional groupby/agg operations
println("\n4. Species-Specific Analysis with GroupBy:");

// THIS IS THE INDUSTRY STANDARD: groupby + aggregation
let species_stats = iris_df
    .groupby(["species"])
    .agg([
        mean("sepal_length").alias("avg_sepal_length"),
        mean("petal_length").alias("avg_petal_length"),
        mean("sepal_width").alias("avg_sepal_width"),
        mean("petal_width").alias("avg_petal_width"),
        count("species").alias("count")
    ]);

println("🌸 Average measurements by species (DataFrame groupby):");
println(species_stats);

// Advanced: Multiple aggregations per column
let detailed_stats = iris_df
    .groupby(["species"])
    .agg([
        mean("petal_length").alias("petal_mean"),
        std("petal_length").alias("petal_std"),
        min("petal_length").alias("petal_min"),
        max("petal_length").alias("petal_max")
    ]);

println("\n📈 Detailed petal length statistics by species:");
println(detailed_stats);

// 5. Feature Engineering - DataFrame column operations
println("\n5. Feature Engineering with DataFrames:");

// Add calculated columns using DataFrame operations
let enhanced_df = iris_df
    .with_columns([
        (col("petal_length") / col("petal_width")).alias("petal_ratio"),
        (col("sepal_length") / col("sepal_width")).alias("sepal_ratio"),
        when(col("petal_length").gt(4.0))
            .then(lit("large"))
            .otherwise(lit("small"))
            .alias("size_category")
    ]);

// Show sample of engineered features
let sample_features = enhanced_df
    .select(["species", "petal_ratio", "sepal_ratio", "size_category"])
    .head(3);

println("⚙️ Sample with engineered features:");
println(sample_features);

// 6. Pattern Discovery - DataFrame filtering and analysis
println("\n6. Pattern Discovery with DataFrame Operations:");

// Filter using DataFrame syntax
let large_petals_df = iris_df.filter(col("petal_length").gt(4.0));
let small_petals_df = iris_df.filter(col("petal_length").le(4.0));

println(f"🌺 Flowers with large petals (>4cm): {large_petals_df.height()}");
println(f"🌼 Flowers with small petals (≤4cm): {small_petals_df.height()}");

// Species distribution analysis
let large_petal_species = large_petals_df
    .groupby(["species"])
    .count()
    .sort("count", descending: true);

println("\n🔍 Large petal species distribution:");
println(large_petal_species);

// Cross-tabulation: Size category by species
let size_crosstab = enhanced_df
    .groupby(["species", "size_category"])
    .count()
    .sort(["species", "size_category"]);

println("\n📉 Size category distribution by species:");
println(size_crosstab);

// 7. Classification Model - DataFrame-based prediction
println("\n7. DataFrame-Based Classification:");
println("🤖 Classification rule: If petal_length > 2.5, then NOT setosa");

// Add prediction column using DataFrame operations
let predictions_df = iris_df
    .with_columns([
        when(col("petal_length").gt(2.5))
            .then(lit("not_setosa"))
            .otherwise(lit("setosa"))
            .alias("predicted"),
        when(col("species").eq(lit("setosa")))
            .then(lit("setosa"))
            .otherwise(lit("not_setosa"))
            .alias("actual")
    ])
    .with_columns([
        (col("predicted").eq(col("actual"))).alias("correct")
    ]);

// Calculate accuracy using DataFrame aggregation
let accuracy_stats = predictions_df
    .agg([
        sum("correct").alias("correct_predictions"),
        count("correct").alias("total_predictions"),
        (sum("correct").cast(Float64) / count("correct").cast(Float64) * 100.0).alias("accuracy_pct")
    ]);

println("🎯 Model Performance (DataFrame aggregation):");
println(accuracy_stats);

// Confusion matrix using groupby
let confusion_matrix = predictions_df
    .groupby(["actual", "predicted"])
    .count()
    .sort(["actual", "predicted"]);

println("\n📈 Confusion Matrix:");
println(confusion_matrix);

println("\n✅ Professional Iris Analysis Complete!");
println("\n📚 What You Learned (INDUSTRY STANDARD DataFrame Operations):");
println("• 📄 DataFrame creation with df![] macro");
println("• 📈 Statistical analysis with .describe(), .agg() methods");
println("• 🔄 GroupBy operations with multiple aggregations");
println("• ⚙️ Feature engineering with .with_columns() and when().then()");
println("• 🔍 Advanced filtering with .filter() and column expressions");
println("• 🤖 Model evaluation with confusion matrix and accuracy metrics");
println("• 📉 Cross-tabulation and pivot-style operations");

println("\n🔥 KEY INSIGHT: This uses REAL DataFrame operations, not toy arrays!");
println("   - Production-ready syntax identical to pandas/polars");
println("   - Scalable to millions of rows");
println("   - Industry-standard data science workflow");

println("\n🚀 Next Steps:");
println("   📊 Try full 150-sample Iris with df.from_csv('iris.csv')");
println("   🚢 Explore Titanic survival analysis with demographic DataFrames");
println("   🍷 Master Wine Quality prediction with 11-feature correlation analysis");