// REPL Demo: Iris Dataset Analysis - The Hello World of Data Science
// Dataset: Classic Fisher's Iris dataset (150 flowers, 4 measurements)  
// Skills: DataFrame operations, groupby, aggregation, statistical analysis
// INDUSTRY STANDARD: Using proper DataFrame syntax, not primitive arrays

println("=== Iris Dataset Analysis - Data Science with DataFrames ===");

// Create the famous Iris dataset using DataFrame (production: df.from_csv())
println("\n1. Loading the Iris Dataset as DataFrame:");
let iris_df = df![
    species => ["setosa", "setosa", "setosa", "setosa", "setosa",
                "versicolor", "versicolor", "versicolor", "versicolor", "versicolor",
                "virginica", "virginica", "virginica", "virginica", "virginica"],
    sepal_length => [5.1, 4.9, 4.7, 4.6, 5.0, 7.0, 6.4, 6.9, 5.5, 6.5, 6.3, 5.8, 7.1, 6.3, 6.5],
    sepal_width => [3.5, 3.0, 3.2, 3.1, 3.6, 3.2, 3.2, 3.1, 2.3, 2.8, 3.3, 2.7, 3.0, 2.9, 3.0],
    petal_length => [1.4, 1.4, 1.3, 1.5, 1.4, 4.7, 4.5, 4.9, 4.0, 4.6, 6.0, 5.1, 5.9, 5.6, 5.8],
    petal_width => [0.2, 0.2, 0.2, 0.2, 0.2, 1.4, 1.5, 1.5, 1.3, 1.5, 2.5, 1.9, 2.1, 1.8, 2.2]
];

println(f"âœ… DataFrame loaded: {iris_df.height()} rows Ã— {iris_df.width()} columns");
println(f"ğŸ“Š Features: sepal_length, sepal_width, petal_length, petal_width, species");
println(f"ğŸŒ¸ Sample size: 15 flowers (subset of full 150-sample dataset)");

// 2. DataFrame Overview - Professional data science
println("\n2. DataFrame Overview:");
let species_counts = iris_df.groupby(["species"]).count();
println("Species distribution:");
println(species_counts);

// 3. Descriptive Statistics - DataFrame operations
println("\n3. Descriptive Statistics with DataFrames:");
let stats_summary = iris_df.select(["sepal_length", "petal_length"]).describe();
println("ğŸ“ˆ Statistical Summary:");
println(stats_summary);

// Manual calculation for demonstration
let sepal_stats = iris_df.select(["sepal_length"]).agg([
    mean("sepal_length").alias("avg_sepal"),
    min("sepal_length").alias("min_sepal"),
    max("sepal_length").alias("max_sepal")
]);
println(f"\nğŸ“Š Sepal Length Statistics:");
println(sepal_stats);
println(f"  Average: {avg_sepal_length:.2f} cm");
println(f"  Range: {min_sepal_length:.1f} - {max_sepal_length:.1f} cm");

let petal_lengths = iris.map(|row| row.petal_length);
let avg_petal_length = petal_lengths.sum() / petal_lengths.len();
println(f"Petal Length Average: {avg_petal_length:.2f} cm");

// 4. Species-specific Analysis - Professional groupby/agg operations
println("\n4. Species-Specific Analysis with GroupBy:");

// THIS IS THE INDUSTRY STANDARD: groupby + aggregation
let species_stats = iris_df
    .groupby(["species"])
    .agg([
        mean("sepal_length").alias("avg_sepal_length"),
        mean("petal_length").alias("avg_petal_length"),
        mean("sepal_width").alias("avg_sepal_width"),
        mean("petal_width").alias("avg_petal_width"),
        count("species").alias("count")
    ]);

println("ğŸŒ¸ Average measurements by species (DataFrame groupby):");
println(species_stats);

// Advanced: Multiple aggregations per column
let detailed_stats = iris_df
    .groupby(["species"])
    .agg([
        mean("petal_length").alias("petal_mean"),
        std("petal_length").alias("petal_std"),
        min("petal_length").alias("petal_min"),
        max("petal_length").alias("petal_max")
    ]);

println("\nğŸ“ˆ Detailed petal length statistics by species:");
println(detailed_stats);

// 5. Feature Engineering - DataFrame column operations
println("\n5. Feature Engineering with DataFrames:");

// Add calculated columns using DataFrame operations
let enhanced_df = iris_df
    .with_columns([
        (col("petal_length") / col("petal_width")).alias("petal_ratio"),
        (col("sepal_length") / col("sepal_width")).alias("sepal_ratio"),
        when(col("petal_length").gt(4.0))
            .then(lit("large"))
            .otherwise(lit("small"))
            .alias("size_category")
    ]);

// Show sample of engineered features
let sample_features = enhanced_df
    .select(["species", "petal_ratio", "sepal_ratio", "size_category"])
    .head(3);

println("âš™ï¸ Sample with engineered features:");
println(sample_features);

// 6. Pattern Discovery - DataFrame filtering and analysis
println("\n6. Pattern Discovery with DataFrame Operations:");

// Filter using DataFrame syntax
let large_petals_df = iris_df.filter(col("petal_length").gt(4.0));
let small_petals_df = iris_df.filter(col("petal_length").le(4.0));

println(f"ğŸŒº Flowers with large petals (>4cm): {large_petals_df.height()}");
println(f"ğŸŒ¼ Flowers with small petals (â‰¤4cm): {small_petals_df.height()}");

// Species distribution analysis
let large_petal_species = large_petals_df
    .groupby(["species"])
    .count()
    .sort("count", descending: true);

println("\nğŸ” Large petal species distribution:");
println(large_petal_species);

// Cross-tabulation: Size category by species
let size_crosstab = enhanced_df
    .groupby(["species", "size_category"])
    .count()
    .sort(["species", "size_category"]);

println("\nğŸ“‰ Size category distribution by species:");
println(size_crosstab);

// 7. Classification Model - DataFrame-based prediction
println("\n7. DataFrame-Based Classification:");
println("ğŸ¤– Classification rule: If petal_length > 2.5, then NOT setosa");

// Add prediction column using DataFrame operations
let predictions_df = iris_df
    .with_columns([
        when(col("petal_length").gt(2.5))
            .then(lit("not_setosa"))
            .otherwise(lit("setosa"))
            .alias("predicted"),
        when(col("species").eq(lit("setosa")))
            .then(lit("setosa"))
            .otherwise(lit("not_setosa"))
            .alias("actual")
    ])
    .with_columns([
        (col("predicted").eq(col("actual"))).alias("correct")
    ]);

// Calculate accuracy using DataFrame aggregation
let accuracy_stats = predictions_df
    .agg([
        sum("correct").alias("correct_predictions"),
        count("correct").alias("total_predictions"),
        (sum("correct").cast(Float64) / count("correct").cast(Float64) * 100.0).alias("accuracy_pct")
    ]);

println("ğŸ¯ Model Performance (DataFrame aggregation):");
println(accuracy_stats);

// Confusion matrix using groupby
let confusion_matrix = predictions_df
    .groupby(["actual", "predicted"])
    .count()
    .sort(["actual", "predicted"]);

println("\nğŸ“ˆ Confusion Matrix:");
println(confusion_matrix);

println("\nâœ… Professional Iris Analysis Complete!");
println("\nğŸ“š What You Learned (INDUSTRY STANDARD DataFrame Operations):");
println("â€¢ ğŸ“„ DataFrame creation with df![] macro");
println("â€¢ ğŸ“ˆ Statistical analysis with .describe(), .agg() methods");
println("â€¢ ğŸ”„ GroupBy operations with multiple aggregations");
println("â€¢ âš™ï¸ Feature engineering with .with_columns() and when().then()");
println("â€¢ ğŸ” Advanced filtering with .filter() and column expressions");
println("â€¢ ğŸ¤– Model evaluation with confusion matrix and accuracy metrics");
println("â€¢ ğŸ“‰ Cross-tabulation and pivot-style operations");

println("\nğŸ”¥ KEY INSIGHT: This uses REAL DataFrame operations, not toy arrays!");
println("   - Production-ready syntax identical to pandas/polars");
println("   - Scalable to millions of rows");
println("   - Industry-standard data science workflow");

println("\nğŸš€ Next Steps:");
println("   ğŸ“Š Try full 150-sample Iris with df.from_csv('iris.csv')");
println("   ğŸš¢ Explore Titanic survival analysis with demographic DataFrames");
println("   ğŸ· Master Wine Quality prediction with 11-feature correlation analysis");