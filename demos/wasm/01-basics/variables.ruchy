// WASM Variables & Memory Management Demo
// Comprehensive variable handling with cross-platform deployment
// Test: ruchy wasm variables.ruchy -o variables.wasm --target browser

// WASM uses a single linear memory space
// All variables exist within this contiguous memory block

fun demonstrate_memory_layout() {
    // These variables are allocated in WASM linear memory
    let byte_value: i32 = 42;        // WASM uses i32 for small ints
    let int_value: i32 = 123456;     // 4 bytes, primary WASM type
    let long_value: i64 = 9876543210; // 8 bytes for large numbers
    
    // Floating point variables
    let float_value: f32 = 3.14159;   // 4 bytes, IEEE 754 format
    let double_value: f64 = 2.71828;  // 8 bytes, IEEE 754 format
    
    println("Memory Layout Demo:");
    println(f"i32 value: {int_value}");
    println(f"i64 value: {long_value}");
    println(f"f32 value: {float_value}");
    println(f"f64 value: {double_value}");
}

// WASM native integer types with performance characteristics
fun integer_type_performance() {
    // i32: Most efficient for counters, indices, small numbers
    let counter: i32 = 0;
    let index: i32 = 42;
    let small_calc: i32 = 100 + 200;
    
    // i64: For large numbers, timestamps, memory addresses
    let timestamp: i64 = 1697123456789;
    let large_number: i64 = 9223372036854775807;
    
    println("Integer Performance Tests:");
    
    // Benchmark i32 operations (fastest)
    let mut i32_result: i32 = 0;
    let mut i = 0;
    while i < 1000000 {
        i32_result = i32_result + i;
        i = i + 1;
    }
    
    // Benchmark i64 operations (slightly slower)
    let mut i64_result: i64 = 0;
    let mut j: i64 = 0;
    while j < 1000000 {
        i64_result = i64_result + j;
        j = j + 1;
    }
    
    println(f"i32 operations completed: {i32_result}");
    println(f"i64 operations completed: {i64_result}");
    println("i32 operations are typically faster in WASM");
}

// IEEE 754 floating point in WASM
fun floating_point_precision() {
    // f32: Single precision (32-bit)
    let pi_f32: f32 = 3.14159265358979323846; // Limited precision
    let e_f32: f32 = 2.71828182845904523536;
    
    // f64: Double precision (64-bit) - more accurate
    let pi_f64: f64 = 3.14159265358979323846;
    let e_f64: f64 = 2.71828182845904523536;
    
    println("Floating Point Precision Comparison:");
    println(f"œÄ as f32: {pi_f32}");
    println(f"œÄ as f64: {pi_f64}");
    println(f"e as f32: {e_f32}");  
    println(f"e as f64: {e_f64}");
    
    // Mathematical operations with different precisions
    let x_f32: f32 = 0.1;
    let y_f32: f32 = 0.2;
    let sum_f32: f32 = x_f32 + y_f32;
    
    let x_f64: f64 = 0.1;
    let y_f64: f64 = 0.2;
    let sum_f64: f64 = x_f64 + y_f64;
    
    println("Floating Point Math Precision:");
    println(f"0.1 + 0.2 as f32: {sum_f32}");
    println(f"0.1 + 0.2 as f64: {sum_f64}");
    println("f64 provides better precision for mathematical operations");
}

// Variables that will be exported to JavaScript
fun calculate_area(width: f64, height: f64) -> f64 {
    width * height
}

fun process_coordinates(x: i32, y: i32) -> i32 {
    x * x + y * y
}

fun format_currency(amount: f64, decimals: i32) -> f64 {
    let multiplier = power_of_ten(decimals);
    (amount * multiplier as f64).round() / multiplier as f64
}

fun power_of_ten(exp: i32) -> i32 {
    let mut result = 1;
    let mut i = 0;
    while i < exp {
        result = result * 10;
        i = i + 1;
    }
    result
}

// Variable passing demonstration
fun variable_interop_demo() {
    // These will be called from JavaScript
    let area = calculate_area(10.5, 20.75);
    let distance = process_coordinates(3, 4);
    let price = format_currency(123.456789, 2);
    
    println("Cross-Platform Variable Demo:");
    println(f"Area: {area}");
    println(f"Distance squared: {distance}");
    println(f"Formatted price: {price}");
}

// Comprehensive variable performance testing
fun benchmark_variable_operations() {
    println("=== WASM Variable Performance Benchmarks ===");
    
    // Integer arithmetic benchmark
    let iterations = 1000000;
    
    // i32 arithmetic (WASM native)
    let mut result_i32: i32 = 0;
    let mut i = 0;
    while i < iterations {
        result_i32 = result_i32 + i * 2 - 1;
        i = i + 1;
    }
    
    // f64 arithmetic
    let mut result_f64: f64 = 0.0;
    let mut j = 0;
    while j < iterations {
        result_f64 = result_f64 + (j as f64) * 2.5 - 1.1;
        j = j + 1;
    }
    
    println(f"i32 arithmetic completed: {result_i32}");
    println(f"f64 arithmetic completed: {result_f64}");
    println("WASM provides consistent performance across platforms");
}

// Comprehensive variable validation
fun validate_variable_types() -> bool {
    let mut all_tests_passed = true;
    
    // Integer range testing
    let max_i32: i32 = 2147483647;
    let min_i32: i32 = -2147483648;
    
    // Basic arithmetic validation (using safe subtraction)
    let test_result = max_i32 + 1000000;
    if test_result <= max_i32 {
        println("ERROR: Integer arithmetic validation failed");
        all_tests_passed = false;
    }
    
    // Floating point validation
    let pi: f64 = 3.14159265;
    let circle_area = pi * 10.0 * 10.0;
    if circle_area < 314.0 || circle_area > 315.0 {
        println("ERROR: Floating point validation failed");
        all_tests_passed = false;
    }
    
    // Cross-platform function validation
    let area_test = calculate_area(5.0, 10.0);
    if area_test != 50.0 {
        println("ERROR: Cross-platform function validation failed");
        all_tests_passed = false;
    }
    
    if all_tests_passed {
        println("‚úÖ All variable type tests passed");
    } else {
        println("‚ùå Some variable type tests failed");
    }
    
    all_tests_passed
}

fun main() {
    println("=== WASM Variables & Memory Management Demo ===");
    
    demonstrate_memory_layout();
    println("");
    
    integer_type_performance();
    println("");
    
    floating_point_precision();
    println("");
    
    variable_interop_demo();
    println("");
    
    benchmark_variable_operations();
    println("");
    
    let validation_passed = validate_variable_types();
    
    if validation_passed {
        println("üéØ Chapter 1.2 Complete: WASM Variables & Memory Management");
        println("Ready for cross-platform deployment!");
    } else {
        println("‚ö†Ô∏è  Validation failed - check implementation");
    }
}

// Platform Deployment Commands:
// Browser: ruchy wasm variables.ruchy -o variables.wasm --target browser
// Node.js: ruchy wasm variables.ruchy -o variables_node.wasm --target nodejs  
// Cloudflare: ruchy wasm variables.ruchy --deploy --deploy-target cloudflare
// Vercel: ruchy wasm variables.ruchy --deploy --deploy-target vercel